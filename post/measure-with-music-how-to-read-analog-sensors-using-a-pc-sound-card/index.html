<!doctype html><html class=no-js lang=en-us xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Measure with Music: How to Read Analog Sensors Using a PC Sound Card"><meta name=author content><meta name=keyword content><link rel="shortcut icon" href=/favicon.ico><title>Measure with Music: How to Read Analog Sensors Using a PC Sound Card &#183; Spaghetti Code with Beer</title><link rel=stylesheet href=https://nagimov.me/css/theme/united2.css><link rel=stylesheet href=https://nagimov.me/css/font-awesome.min.css><link rel=stylesheet href=https://nagimov.me/css/style.css><script>var remark_config={host:"https://remark.ngm.me",site_id:'nagimov_me',components:['embed'],theme:'light',};</script><script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);</script><script>(function(f,a,t,h,o,m){a[h]=a[h]||function(){(a[h].q=a[h].q||[]).push(arguments)};o=f.createElement('script'),m=f.getElementsByTagName('script')[0];o.async=1;o.src=t;o.id='fathom-script';m.parentNode.insertBefore(o,m)})(document,window,'https://fathom.ngm.me/tracker.js','fathom');fathom('set','siteId','RYEFY');fathom('trackPageview');</script><link href rel=alternate type=application/rss+xml title="Spaghetti Code with Beer"></head><body lang=en><div class=container><div class=row><div class="navbar navbar-default" role=navigation><div class=navbar-header><a class=navbar-brand href=https://nagimov.me>Spaghetti Code with Beer</a></div><div class="navbar-collapse collapse navbar-responsive-collapse"><ul class="nav navbar-nav navbar-right" style=font-size:18px><li><a href=https://nagimov.me>Home</a></li><li><a href=https://nagimov.me/post/>Posts</a></li><li><a href=/about/>About</a></li></ul></div></div></div></div><div class=container><div class=row><div class=col-md-12 style=display:flex;justify-content:space-between><div><h3>Measure with Music: How to Read Analog Sensors Using a PC Sound Card</h3></div><div>&nbsp;&nbsp;&nbsp;&nbsp;</div><div style=margin-bottom:10.5px;margin-top:21px><span class="label label-primary">2021-06-23</span></div></div></div><div class=row><div class=col-md-12><center><h4>(GIF for attention)</h4></center><p><img src=/images/sound-card-daq/liquid_level.gif#center alt></p><p>This post describes a simple method of reading resistive and capacitive sensors using a standard PC sound card. Virtually any desktop or laptop could be turned into a simple data acquisition system using this method. Thanks to moderate system requirements, even the very old computers can be repurposed for this application. Socket 478 based platforms from early 2000&rsquo;s with integrated sound cards are readily available for ~free from recycling bins and are perfectly capable of running the data acquisition software (thankfully, Debian still supports 32-bit platforms). With the total cost of other components under $1, this can hopefully bring affordable and interactive data acquisition to DIYers, experimenters and students in science and physics classes. I do not recommend (in fact, I highly discourage) using this method for anything but educational purposes. It is not meant to be used for industrial or even lab data acquisition &ndash; there are much better alternatives.</p><p>Another point of this post is to demonstrate that old PC motherboards are under-appreciated in DIY circles. Even the older ATX motherboards are equipped with many useful capabilities:</p><ul><li>audio ADCs and DACs (AC-coupled)</li><li>DC voltage DACs for fan speed control</li><li>hall effect sensor encoders for fan RPM readback</li><li>PWM outputs for RPM control on 4-pin fan headers</li><li><a href=https://blog.atx.name/twilight-vga-i2c-breakout-board/>I2C busses in video ports</a></li><li>dry contact inputs: &ldquo;chassis intrusion&rdquo; switches, audio jack detection contacts on front panel audio headers</li><li>multiple voltage references (~1V core and memory voltages, 3.3V, 5V, 12V)</li></ul><p>In addition, newer motherboards are equipped with goodies like thermistor inputs (e.g. headers T_SEN1, T_SEN2, etc. on MSI motherboards) that might not necessarily measure temperatures of water cooling loops :)</p><p>Example circuits are purposefully simplified to utilize only widely available passive components. While the quality of signal processing can be improved by introducing simple buffering and amplification, additional opamps and voltage sources would unnecessarily complicate the method, introduce additional expenses, and require more advanced electronics and soldering skills to implement. Simplicity of using only passive networks is a desired feature, and not a bug.</p><p><strong>The text, illustrations, schematics and code snippets of this post are provided &ldquo;as-is&rdquo; without warranty of any kind. Please refer to the <a href=https://github.com/nagimov/sound-card-daq/blob/main/LICENSE>LICENSE</a> before using any of it.</strong></p><p>The code is available <a href=https://github.com/nagimov/sound-card-daq>on github</a>.</p><h3 id=toc>TOC</h3><ul><li><a href=#pc-sound-cards-and-audio-interfaces>PC sound cards and audio interfaces</a></li><li><a href=#hardware-and-software>Hardware and software</a><ul><li><a href=#sound-card-io>Sound card I/O</a></li><li><a href=#sensors-and-passives>Sensors and passives</a></li></ul></li><li><a href=#reading-resistive-sensors>Reading resistive sensors</a><ul><li><a href=#circuit-design>Circuit design</a></li><li><a href=#hardware-setup>Hardware setup</a></li><li><a href=#software-setup>Software setup</a></li><li><a href=#module-description>Module description</a></li><li><a href=#adjusting-input-gain>Adjusting input gain</a></li><li><a href=#temperature-measurement>Temperature measurement</a></li><li><a href=#measurement-errors>Measurement errors</a></li></ul></li><li><a href=#reading-capacitive-or-inductive-sensors>Reading capacitive or inductive sensors</a><ul><li><a href=#measuring-frequency-response>Measuring frequency response</a></li><li><a href=#capacitance-or-inductance-measurements>Capacitance or inductance measurements</a></li><li><a href=#circuit-design-1>Circuit design</a></li><li><a href=#hardware-setup-1>Hardware setup</a></li><li><a href=#software-setup-1>Software setup</a></li><li><a href=#water-level-measurement>Water level measurement</a></li></ul></li><li><a href=#troubleshooting>Troubleshooting</a></li></ul><h3 id=pc-sound-cards-and-audio-interfaces>PC sound cards and audio interfaces</h3><p>PC sound cards can be useful for projects that require kHz-rate analog inputs (see <a href=https://homediyelectronics.com/projects/howtomakeafreesoundcardpcoscilloscope/>DIY oscilloscope</a>). However they can&rsquo;t be directly used for measuring DC signals since audio ADCs reject the DC component. Hence, the consensus is that sound cards are useless for reading any sensors, and DIY monitoring projects are usually based on ubiquitous Arduinos and Raspberry Pies.</p><p>However, the majority of sensors aren&rsquo;t inherently DC. Standardized sensor interfaces use DC signals (0-5V, 0-10V, 4-20mA) due to simplicity of measuring and generating DC voltages and currents. Many underlying sensing elements are inherently resistive (thermistors, strain gauges in force and pressure transducers, potentiometers, light dependent resistors, etc.), capacitive (non-contact displacement sensors, proximity sensors, flow meters, level sensors, accelerometers, etc.) or inductive. The convention of reading sensors using DC signals is merely a convenience.</p><p>This post demonstrates the approach to reading such sensors using a PC sound card. A 10k thermistor and a DIY level probe are used in this example, but these methods can be extended to any resistive, capacitive and inductive measurements.</p><h3 id=hardware-and-software>Hardware and software</h3><p>The system is based on a standard PC with an integrated sound card. I use an old AM2 motherboard running Debian, but this should work on any modern Linux distribution. The only OS-dependent part is the interface for playing/recording wav files to/from the sound card using PulseAudio. This could be adapted to work with the Windows sound subsystem as well.</p><p>I conventionally use python with numpy, scipy and matplotlib to glue the pieces together.</p><h4 id=sound-card-io>Sound card I/O</h4><p>There are a few ways to physically interface with the sound card:</p><ul><li>use audio pig tail cables plugged into 3.5mm audio jacks (could be salvaged from old speakers, headphones, etc.)</li><li>use dupont style sockets plugged into motherboard audio headers (could be salvaged from old PC cases)<ul><li>note: make sure to activate front panel audio ports <a href=https://www.intel.com/content/www/us/en/support/articles/000005512/boards-and-kits/desktop-boards.html>by connecting <code>SENSE_SEND</code> to <code>SENSE1_RETURN</code> and <code>SENSE2_RETURN</code> pins</a> when using HD Audio headers.</li></ul></li></ul><h4 id=sensors-and-passives>Sensors and passives</h4><p>I use a standard 10kΩ NTC thermistor salvaged from a digital thermometer as an example of a resistive sensor. These thermistors can be found for less than a dollar apiece on amazon or ebay.</p><p>A level probe sensor is made from two pieces of aluminum foil (available from your kitchen drawers) glued onto plastic frames (can be 3d-printed or cut from a thin sheet of plastic &ndash; milk jug, old credit card, etc.).</p><p>Required passive components:</p><ul><li>three 10kΩ resistors for thermistor measurements</li><li>one ~1mH inductor and one ~100nF capacitor for level probe measurements<ul><li>note: different combinations of inductance and capacitance can be used as well (see <a href=#circuit-design-1>Circuit design</a>)</li></ul></li></ul><h3 id=reading-resistive-sensors>Reading resistive sensors</h3><h4 id=circuit-design>Circuit design</h4><p>Resistance can be measured using an AC voltage source and AC voltmeter in a simple voltage divider arrangement:</p><p><img src=/images/sound-card-daq/ac-bridge.png#center alt></p><p>The sound card output is used as the AC voltage source and its input is used as the voltmeter. A typical impedance of sound card outputs is under 0.1kΩ and it can be safely excluded from the equation. An input impedance is usually at the order of 10kΩ, so technically it should be considered for in resistance calculations. In practice, ignoring the input impedance results in errors of less than 1°C for the temperature range from -25°C to +25°C, and less than 2°C for temperatures below +35°C.</p><p>There is however one problem with this approach. Due to highly adjustable gain of audio DACs and ADCs (aka volume control), signal amplitudes cannot be easily converted to voltages and vice versa. E.g., audio output of my desktop has the RMS voltage around 1.2V at its max volume, but my laptop isn&rsquo;t guaranteed to have the same voltage. In audio terms, this results in slight volume variations which isn&rsquo;t a big deal. However these variations could introduce significant errors to resistance measurements.</p><p>We can of course measure the gain of audio input/output directly using a voltmeter. That would work, but such setup wouldn&rsquo;t be portable since the measured gain would only describe the one particular system.</p><p>Another solution is to measure the ratio of input to output gains using a voltage divider with known resistors. This ratio can be used to determine the ratio of input to output voltages and calculate the unknown resistance. Thanks to the two available audio channels on stereo inputs and outputs, one channel can be used to determine the gain ratio and another one to measure the resistance.</p><p><img src=/images/sound-card-daq/audio-channels.png#center alt></p><h4 id=hardware-setup>Hardware setup</h4><p>I used an audio breakout board with two 3.5mm ports to simplify the assembly:</p><p><img src=/images/sound-card-daq/thermistor-breakout-board.png#center alt></p><p>Resistors R1, R2 and R3 are soldered directly on the board (R2 is in 0603 SMD package and is hard to see on the picture). Thermistor is connected to header pins. Input and output 3.5mm plugs are connected to the sound card using audio cables.</p><p><img src=/images/sound-card-daq/thermistor-assembly.png#center alt></p><h4 id=software-setup>Software setup</h4><p><strong>NOTE:</strong> Make sure that both input and output jacks are plugged in before continuing. PulseAudio recognizes if ports are unplugged and deactivates them accordingly.</p><p>To communicate with the sound card, input and output devices must be identified. PulseAudio commands <code>pacmd list-sinks</code> and <code>pacmd list-sources</code> can be used to display available devices:</p><pre><code>$ pacmd list-sinks | grep name:
    name: &lt;alsa_output.pci-0000_00_07.0.analog-stereo&gt;
$ pacmd list-sources | grep name: | grep -v monitor
    name: &lt;alsa_input.pci-0000_00_07.0.analog-stereo&gt;
</code></pre><p>In my case, the output device is <code>alsa_output.pci-0000_00_07.0.analog-stereo</code> and the input device is <code>alsa_input.pci-0000_00_07.0.analog-stereo</code>. These names should be specified in the <code>$HOME/soundcard.cfg</code> file in the following format (<code>vol_record</code> parameter is configured later):</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-INI data-lang=INI><span style=color:#007020;font-weight:700>[SOUNDCARD]</span>
<span style=color:#4070a0>pa_sink</span> <span style=color:#666>=</span> <span style=color:#4070a0>alsa_output.pci-0000_00_07.0.analog-stereo</span>
<span style=color:#4070a0>pa_source</span> <span style=color:#666>=</span> <span style=color:#4070a0>alsa_input.pci-0000_00_07.0.analog-stereo</span>
<span style=color:#4070a0>vol_record</span> <span style=color:#666>=</span> <span style=color:#4070a0>-1</span>
</code></pre></div><h4 id=module-description>Module description</h4><p>All of the python glue is combined into a simple <a href=https://github.com/nagimov/sound-card-daq/blob/main/soundcard.py><code>soundcard.py</code> module</a> with a handful of constants and functions.</p><p>Imports are as follows (<code>numpy</code> is used for array manipulation and <code>scipy</code> provides a convenient <code>wavfile</code> interface):</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>configparser</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>os</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>subprocess</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>time</span>
<span style=color:#007020;font-weight:700>from</span> <span style=color:#0e84b5;font-weight:700>scipy.io</span> <span style=color:#007020;font-weight:700>import</span> wavfile
</code></pre></div><p>Constants specify the file locations, define the standard 44.1kHz PCM WAV format and time delays:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>CFG_FILE <span style=color:#666>=</span> os<span style=color:#666>.</span>path<span style=color:#666>.</span>join(os<span style=color:#666>.</span>environ[<span style=color:#4070a0>&#39;HOME&#39;</span>], <span style=color:#4070a0>&#39;soundcard.cfg&#39;</span>)
WAV_FILE_OUT <span style=color:#666>=</span> <span style=color:#4070a0>&#39;/tmp/out.wav&#39;</span>
WAV_FILE_IN <span style=color:#666>=</span> <span style=color:#4070a0>&#39;/tmp/in.wav&#39;</span>
SAMPLE_RATE <span style=color:#666>=</span> <span style=color:#40a070>44100</span>
BIT_DEPTH <span style=color:#666>=</span> np<span style=color:#666>.</span>int16
WAV_FORMAT <span style=color:#666>=</span> <span style=color:#4070a0>&#39;s16ne&#39;</span>
VOL_PLAY <span style=color:#666>=</span> <span style=color:#40a070>2</span> <span style=color:#666>**</span> <span style=color:#40a070>16</span> <span style=color:#666>-</span> <span style=color:#40a070>1</span>
DURATION_RECORD <span style=color:#666>=</span> <span style=color:#40a070>2</span>
PAUSE_PRE_PLAY <span style=color:#666>=</span> <span style=color:#40a070>2</span>
PAUSE_PRE_RECORD <span style=color:#666>=</span> <span style=color:#40a070>2</span>
PAUSE_POST_RECORD <span style=color:#666>=</span> <span style=color:#40a070>2</span>
DURATION_PLAY <span style=color:#666>=</span> DURATION_RECORD <span style=color:#666>+</span> PAUSE_PRE_RECORD <span style=color:#666>+</span> PAUSE_POST_RECORD
</code></pre></div><p>The config file is parsed and verifed using the <code>configparser</code> module:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>config <span style=color:#666>=</span> configparser<span style=color:#666>.</span>ConfigParser()
config<span style=color:#666>.</span>read(CFG_FILE)
PA_SINK <span style=color:#666>=</span> config<span style=color:#666>.</span>get(<span style=color:#4070a0>&#39;SOUNDCARD&#39;</span>, <span style=color:#4070a0>&#39;PA_SINK&#39;</span>, fallback<span style=color:#666>=</span><span style=color:#4070a0>&#39;&#39;</span>)
PA_SOURCE <span style=color:#666>=</span> config<span style=color:#666>.</span>get(<span style=color:#4070a0>&#39;SOUNDCARD&#39;</span>, <span style=color:#4070a0>&#39;PA_SOURCE&#39;</span>, fallback<span style=color:#666>=</span><span style=color:#4070a0>&#39;&#39;</span>)
VOL_RECORD <span style=color:#666>=</span> config<span style=color:#666>.</span>getint(<span style=color:#4070a0>&#39;SOUNDCARD&#39;</span>, <span style=color:#4070a0>&#39;VOL_RECORD&#39;</span>, fallback<span style=color:#666>=-</span><span style=color:#40a070>1</span>)
<span style=color:#007020;font-weight:700>if</span> PA_SINK <span style=color:#666>==</span> <span style=color:#4070a0>&#39;&#39;</span> <span style=color:#007020;font-weight:700>or</span> PA_SOURCE <span style=color:#666>==</span> <span style=color:#4070a0>&#39;&#39;</span> <span style=color:#007020;font-weight:700>or</span> VOL_RECORD <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>:
    config[<span style=color:#4070a0>&#39;SOUNDCARD&#39;</span>] <span style=color:#666>=</span> {<span style=color:#4070a0>&#39;PA_SINK&#39;</span>: PA_SINK, <span style=color:#4070a0>&#39;PA_SOURCE&#39;</span>: PA_SOURCE, <span style=color:#4070a0>&#39;VOL_RECORD&#39;</span>: VOL_RECORD}
    <span style=color:#007020;font-weight:700>with</span> <span style=color:#007020>open</span>(CFG_FILE, <span style=color:#4070a0>&#39;w&#39;</span>) <span style=color:#007020;font-weight:700>as</span> cfg:
        config<span style=color:#666>.</span>write(cfg)
<span style=color:#007020;font-weight:700>if</span> PA_SINK <span style=color:#666>==</span> <span style=color:#4070a0>&#39;&#39;</span> <span style=color:#007020;font-weight:700>or</span> PA_SOURCE <span style=color:#666>==</span> <span style=color:#4070a0>&#39;&#39;</span>:
    <span style=color:#007020;font-weight:700>raise</span> <span style=color:#007020>ValueError</span>(f<span style=color:#4070a0>&#39;PA_SINK or PA_SOURCE are not set! Specify PulseAudio devices in {CFG_FILE}&#39;</span>)
</code></pre></div><p>The following functions define the waveforms to be played over the audio output. A pure sine wave is an obvious choice, and a 440Hz (middle C) is a perfect pitch for the task. White noise is defined here as well &ndash; it is a useful test signal for frequency response measurements:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>sine_wave</span>(frequency<span style=color:#666>=</span><span style=color:#40a070>440</span>):
    time_points <span style=color:#666>=</span> np<span style=color:#666>.</span>linspace(<span style=color:#40a070>0</span>, DURATION_PLAY, SAMPLE_RATE <span style=color:#666>*</span> DURATION_PLAY)
    <span style=color:#007020;font-weight:700>return</span> np<span style=color:#666>.</span>iinfo(BIT_DEPTH)<span style=color:#666>.</span>max <span style=color:#666>*</span> np<span style=color:#666>.</span>sin(frequency <span style=color:#666>*</span> <span style=color:#40a070>2</span> <span style=color:#666>*</span> np<span style=color:#666>.</span>pi <span style=color:#666>*</span> time_points)

<span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>white_noise</span>():
    <span style=color:#007020;font-weight:700>return</span> np<span style=color:#666>.</span>random<span style=color:#666>.</span>uniform(np<span style=color:#666>.</span>iinfo(BIT_DEPTH)<span style=color:#666>.</span>min, np<span style=color:#666>.</span>iinfo(BIT_DEPTH)<span style=color:#666>.</span>max, SAMPLE_RATE <span style=color:#666>*</span> DURATION_PLAY)
</code></pre></div><p>After playing this waveform through the sound card and recording it back, we need to make sure that the recorded sine wave isn&rsquo;t clipped, otherwise the output amplitude won&rsquo;t be determined correctly. This might happen if the recording level is too high. This function verifies that the waveform fits between the max and min values of 16-bit PCM WAV file:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>is_waveform_clipped</span>(waveform):
    clipped_top <span style=color:#666>=</span> np<span style=color:#666>.</span>max(waveform) <span style=color:#666>&gt;=</span> np<span style=color:#666>.</span>iinfo(BIT_DEPTH)<span style=color:#666>.</span>max
    clipped_bottom <span style=color:#666>=</span> np<span style=color:#666>.</span>min(waveform) <span style=color:#666>&lt;=</span> np<span style=color:#666>.</span>iinfo(BIT_DEPTH)<span style=color:#666>.</span>min
    <span style=color:#007020;font-weight:700>return</span> clipped_top <span style=color:#007020;font-weight:700>or</span> clipped_bottom
</code></pre></div><p>The simplest way to play/record the waveforms to/from the sound card is to use <code>paplay</code> and <code>parecord</code>. These commands only work with wav files, so <code>scipy.io.wavfile</code> is used to convert the files to numpy arrays and vice versa. Prior to playing and recording the signal, input and output levels are adjusted to predefined levels using <code>pacmd set-sink-volume</code> and <code>pacmd set-source-volume</code>:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>write_waveform</span>(waveform):
    <span style=color:#007020;font-weight:700>if</span> os<span style=color:#666>.</span>path<span style=color:#666>.</span>exists(WAV_FILE_OUT):
        os<span style=color:#666>.</span>remove(WAV_FILE_OUT)
    wavfile<span style=color:#666>.</span>write(WAV_FILE_OUT, SAMPLE_RATE, np<span style=color:#666>.</span>hstack((waveform, waveform))<span style=color:#666>.</span>astype(BIT_DEPTH))

<span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>play_wav</span>():
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pacmd&#39;</span>, <span style=color:#4070a0>&#39;set-sink-volume&#39;</span>, PA_SINK, <span style=color:#4070a0>&#39;0&#39;</span>])
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pacmd&#39;</span>, <span style=color:#4070a0>&#39;set-sink-volume&#39;</span>, PA_SINK, f<span style=color:#4070a0>&#39;{int(VOL_PLAY)}&#39;</span>])
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;paplay&#39;</span>, WAV_FILE_OUT, f<span style=color:#4070a0>&#39;--device={PA_SINK}&#39;</span>])

<span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>record_wav</span>():
    <span style=color:#007020;font-weight:700>if</span> VOL_RECORD <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>:
        <span style=color:#007020;font-weight:700>raise</span> <span style=color:#007020>ValueError</span>(<span style=color:#4070a0>&#39;VOL_RECORD parameter is not set! Use gain_tune.py to configure recording gain&#39;</span>)
    <span style=color:#007020;font-weight:700>if</span> os<span style=color:#666>.</span>path<span style=color:#666>.</span>exists(WAV_FILE_IN):
        os<span style=color:#666>.</span>remove(WAV_FILE_IN)
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pacmd&#39;</span>, <span style=color:#4070a0>&#39;set-source-volume&#39;</span>, PA_SOURCE, <span style=color:#4070a0>&#39;0&#39;</span>])
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pacmd&#39;</span>, <span style=color:#4070a0>&#39;set-source-volume&#39;</span>, PA_SOURCE, f<span style=color:#4070a0>&#39;{int(VOL_RECORD)}&#39;</span>])
    subprocess<span style=color:#666>.</span>Popen(
        [
            <span style=color:#4070a0>&#39;parecord&#39;</span>,
            f<span style=color:#4070a0>&#39;--device={PA_SOURCE}&#39;</span>,
            f<span style=color:#4070a0>&#39;--rate={SAMPLE_RATE}&#39;</span>,
            f<span style=color:#4070a0>&#39;--format={WAV_FORMAT}&#39;</span>,
            <span style=color:#4070a0>&#39;--channels=2&#39;</span>,
            f<span style=color:#4070a0>&#39;--process-time-msec={DURATION_RECORD*1000}&#39;</span>,
            WAV_FILE_IN,
        ]
    )

<span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>read_waveform</span>():
    _, waveform <span style=color:#666>=</span> wavfile<span style=color:#666>.</span>read(WAV_FILE_IN)
    <span style=color:#007020;font-weight:700>return</span> waveform
</code></pre></div><p>Next function combines the following tasks:</p><ul><li>accept waveform numpy array parameter and save it to wav file</li><li>start playing wav file to line output</li><li>wait for output to stabilize</li><li>start recording to wav file from line input</li><li>wait while signal is being recorded</li><li>stop recording process</li><li>convert recorded wav file to numpy array</li><li>wait for sound to finish playing and stop PulseAudio player</li><li>verify that recorded waveform isn&rsquo;t clipped</li></ul><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>play_and_record</span>(waveform):
    write_waveform(waveform)
    time<span style=color:#666>.</span>sleep(PAUSE_PRE_PLAY)
    play_wav()
    time<span style=color:#666>.</span>sleep(PAUSE_PRE_RECORD)
    record_wav()
    time<span style=color:#666>.</span>sleep(DURATION_RECORD)
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pkill&#39;</span>, <span style=color:#4070a0>&#39;parecord&#39;</span>])
    time<span style=color:#666>.</span>sleep(PAUSE_POST_RECORD)
    new_waveform <span style=color:#666>=</span> read_waveform()
    subprocess<span style=color:#666>.</span>Popen([<span style=color:#4070a0>&#39;pkill&#39;</span>, <span style=color:#4070a0>&#39;paplay&#39;</span>])
    <span style=color:#007020;font-weight:700>if</span> is_waveform_clipped(new_waveform):
        <span style=color:#007020;font-weight:700>raise</span> <span style=color:#007020>ValueError</span>(<span style=color:#4070a0>&#39;Recorded waveform is clipped - reduce VOL_RECORD parameter&#39;</span>)
    new_waveform_L <span style=color:#666>=</span> new_waveform<span style=color:#666>.</span>astype(<span style=color:#4070a0>&#39;int&#39;</span>)[:, <span style=color:#40a070>0</span>]
    new_waveform_R <span style=color:#666>=</span> new_waveform<span style=color:#666>.</span>astype(<span style=color:#4070a0>&#39;int&#39;</span>)[:, <span style=color:#40a070>1</span>]
    <span style=color:#007020;font-weight:700>return</span> new_waveform_L, new_waveform_R
</code></pre></div><p>Finally, a simple helper function is defined to calculate RMS values of waveforms:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>def</span> <span style=color:#06287e>rms</span>(waveform):
    <span style=color:#007020;font-weight:700>return</span> np<span style=color:#666>.</span>sqrt(np<span style=color:#666>.</span>mean(np<span style=color:#666>.</span>square(waveform)))
</code></pre></div><h4 id=adjusting-input-gain>Adjusting input gain</h4><p>To maximize the resolution of audio waveforms, recording levels should be adjusted in a way that scales input signal amplitudes close to the maximum range of 16-bit PCM WAV format. This is done by repeatedly playing and recording the sine wave while adjusting the recording level and testing the input for clipping. The <a href=https://github.com/nagimov/sound-card-daq/blob/main/gain_tune.py><code>gain_tune.py</code> script</a> tests multiple recording levels until it finds the highest one that doesn&rsquo;t clip the signal. Recording level is then saved to the <code>$HOME/soundcard.cfg</code> config file:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>configparser</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>subprocess</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>time</span>

MARGIN <span style=color:#666>=</span> <span style=color:#40a070>0.75</span>
STEPS_TOTAL <span style=color:#666>=</span> <span style=color:#40a070>5</span>

step <span style=color:#666>=</span> <span style=color:#40a070>0</span>
lo, hi <span style=color:#666>=</span> <span style=color:#40a070>0</span>, <span style=color:#40a070>65535</span>
<span style=color:#007020;font-weight:700>while</span> True:
    vol_current <span style=color:#666>=</span> <span style=color:#007020>int</span>((hi <span style=color:#666>+</span> lo) <span style=color:#666>/</span> <span style=color:#40a070>2</span>)
    sc<span style=color:#666>.</span>VOL_RECORD <span style=color:#666>=</span> vol_current
    <span style=color:#007020;font-weight:700>try</span>:
        w_L, w_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave())
        rms_L, rms_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>rms(w_L), sc<span style=color:#666>.</span>rms(w_R)
        lo <span style=color:#666>=</span> vol_current
        step <span style=color:#666>+=</span> <span style=color:#40a070>1</span>
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;no clipping detected at VOL_RECORD = {vol_current}, rms_L = {rms_L:.2f}, rms_R = {rms_R:.2f}&#39;</span>)
    <span style=color:#007020;font-weight:700>except</span> <span style=color:#007020>ValueError</span>:
        hi <span style=color:#666>=</span> vol_current
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;clipping detected at VOL_RECORD = {vol_current}&#39;</span>)
    <span style=color:#007020;font-weight:700>if</span> step <span style=color:#666>&gt;</span> STEPS_TOTAL:
        vol_current <span style=color:#666>=</span> <span style=color:#007020>int</span>(sc<span style=color:#666>.</span>VOL_RECORD <span style=color:#666>*</span> MARGIN)
        sc<span style=color:#666>.</span>config[<span style=color:#4070a0>&#39;SOUNDCARD&#39;</span>][<span style=color:#4070a0>&#39;VOL_RECORD&#39;</span>] <span style=color:#666>=</span> <span style=color:#007020>str</span>(vol_current)
        <span style=color:#007020;font-weight:700>with</span> <span style=color:#007020>open</span>(sc<span style=color:#666>.</span>CFG_FILE, <span style=color:#4070a0>&#39;w&#39;</span>) <span style=color:#007020;font-weight:700>as</span> cfg:
            sc<span style=color:#666>.</span>config<span style=color:#666>.</span>write(cfg)
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;VOL_RECORD value {vol_current} saved to {sc.CFG_FILE}&#39;</span>)
        <span style=color:#007020;font-weight:700>break</span>
</code></pre></div><p>The level should also be adjusted for variabilities of input amplitude. In this case, they are caused by temperature variations. I use the thermistor to monitor outside temperatures: assuming high of 40°C on the worst summer day, the lowest corresponding resistance of 10kΩ thermistor is ~5kΩ. <code>MARGIN</code> is adjusted to reflect the voltage ratio of reference to measurement channels for this condition (adjust this margin accordingly for your sensors):</p><pre><code>(10 kΩ / (10 kΩ + 10 kΩ)) / (10 kΩ / (5 kΩ + 10 kΩ)) = 0.75
</code></pre><p>The tuning script performs a binary search until the gain is determined with specified accuracy (determined by <code>STEPS_TOTAL</code>):</p><pre><code>$ cat ~/soundcard.cfg | grep vol_record
vol_record = -1
$ python3 gain_tune.py
clipping detected at VOL_RECORD = 32767
no clipping detected at VOL_RECORD = 16383, rms_L = 5516.48, rms_R = 5291.19
no clipping detected at VOL_RECORD = 24575, rms_L = 18677.35, rms_R = 17995.21
clipping detected at VOL_RECORD = 28671
clipping detected at VOL_RECORD = 26623
no clipping detected at VOL_RECORD = 25599, rms_L = 21104.81, rms_R = 20477.67
no clipping detected at VOL_RECORD = 26111, rms_L = 22477.60, rms_R = 22008.95
clipping detected at VOL_RECORD = 26367
no clipping detected at VOL_RECORD = 26239, rms_L = 22470.11, rms_R = 22005.82
no clipping detected at VOL_RECORD = 26303, rms_L = 22469.06, rms_R = 22005.82
VOL_RECORD value 19727 saved to /home/nagimov/soundcard.cfg
$ cat ~/soundcard.cfg | grep vol_record
vol_record = 19727
</code></pre><h4 id=temperature-measurement>Temperature measurement</h4><p>Resistance values of <code>R_1</code>, <code>R_2</code> and <code>R_3</code> are measured directly and used in the <a href=https://github.com/nagimov/sound-card-daq/blob/main/thermistor.py><code>thermistor.py</code> script</a> to slightly improve the accuracy. <a href=https://en.wikipedia.org/wiki/Steinhart%E2%80%93Hart_equation>Steinhart-Hart equation</a> is used for resistance-to-temperature conversion:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>

R_1 <span style=color:#666>=</span> <span style=color:#40a070>9.95e3</span>
R_2 <span style=color:#666>=</span> <span style=color:#40a070>10.0e3</span>
R_3 <span style=color:#666>=</span> <span style=color:#40a070>9.94e3</span>
A <span style=color:#666>=</span> <span style=color:#40a070>2.108508173e-3</span>
B <span style=color:#666>=</span> <span style=color:#40a070>0.7979204727e-4</span>
C <span style=color:#666>=</span> <span style=color:#40a070>6.535076315e-7</span>

<span style=color:#007020;font-weight:700>while</span> True:
    w_L, w_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave())
    rms_L, rms_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>rms(w_L), sc<span style=color:#666>.</span>rms(w_R)
    gain_ratio <span style=color:#666>=</span> rms_R <span style=color:#666>*</span> (R_1 <span style=color:#666>+</span> R_2) <span style=color:#666>/</span> R_2
    R_NTC <span style=color:#666>=</span> R_3 <span style=color:#666>*</span> (gain_ratio <span style=color:#666>/</span> rms_L <span style=color:#666>-</span> <span style=color:#40a070>1</span>)
    T_NTC <span style=color:#666>=</span> <span style=color:#40a070>1</span> <span style=color:#666>/</span> (A <span style=color:#666>+</span> B <span style=color:#666>*</span> np<span style=color:#666>.</span>log(R_NTC) <span style=color:#666>+</span> C <span style=color:#666>*</span> np<span style=color:#666>.</span>log(R_NTC) <span style=color:#666>**</span> <span style=color:#40a070>3</span>) <span style=color:#666>-</span> <span style=color:#40a070>273.15</span>
    <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;R_NTC = {R_NTC:.1f} Ohm, T_NTC = {T_NTC:.1f} C&#39;</span>)
</code></pre></div><h4 id=measurement-errors>Measurement errors</h4><p>To simplify the measurement, impedance of the sound card input is not accounted for. Measurement errors caused by this are tolerable for the ambient temperature monitoring.</p><p>Estimated measurement errors in the range from 1kΩ to 100kΩ (defined using an Ohm-meter and an adjustable potentiometer):</p><p><img src=/images/sound-card-daq/thermistor_error_R.png#center alt></p><p>Same measurement errors represented in temperature units in the range from -25°C to +35°C:</p><p><img src=/images/sound-card-daq/thermistor_error_T.png#center alt></p><p>Errors caused by the unknown input impedance can be evaluated similarly for other kinds of measurements. These errors can be reduced by substracting the above error curves from measurements. Another method is to define the input impedance by measuring a known resistance and adjusting for the additional voltage drop at the input side.</p><h3 id=reading-capacitive-or-inductive-sensors>Reading capacitive or inductive sensors</h3><p>For resistance measurements, the AC signal from the sound card was fixed at 440Hz, since resistive circuits (i.e. without inductance and capacitance) are not affected by signal frequency. For circuits with capacitors or inductors this is not the case &ndash; their behavior is frequency dependent. This fact could be exploited to read such sensors by measuring their frequency response characteristics. Since sound cards can both generate and record AC signals at various frequencies, they can be used to measure capacitance and inductance. Note that the usable frequency range of audio equipment (including PC sound cards) is limited to the range of audible frequencies: from ~20Hz to ~20,000Hz. The exact low and high limits are hardware-dependent and can be determined experimentally.</p><h4 id=measuring-frequency-response>Measuring frequency response</h4><p>The frequency of output audio signal can be adjusted in the code by supplying an optional <code>freq</code> parameter to the <code>sine_wave()</code> function. To measure the frequency response characteristic of circuits, the output signal frequency is varied in steps within defined limits and the input amplitude is measured at each step.</p><p>In the first demonstration, the sound card itself is characterized for the frequency response. In this measurement, the output of the sound card is connected directly to its input using an audio cable. With no circuitry in between, this measurement describes the combined frequency response of the DAC and ADC circuits of the sound card.</p><p>The first step is to re-tune the recording gain using the <a href=https://github.com/nagimov/sound-card-daq/blob/main/gain_tune.py><code>gain_tune.py</code> script</a>:</p><pre><code>$ python3 gain_tune.py
clipping detected at VOL_RECORD = 32767
no clipping detected at VOL_RECORD = 16383, rms_L = 11937.79, rms_R = 11494.02
clipping detected at VOL_RECORD = 24575
clipping detected at VOL_RECORD = 20479
no clipping detected at VOL_RECORD = 18431, rms_L = 17088.12, rms_R = 16542.01
no clipping detected at VOL_RECORD = 19455, rms_L = 20112.67, rms_R = 19555.55
no clipping detected at VOL_RECORD = 19967, rms_L = 21752.07, rms_R = 21287.34
no clipping detected at VOL_RECORD = 20223, rms_L = 22599.30, rms_R = 22116.54
no clipping detected at VOL_RECORD = 20351, rms_L = 23028.75, rms_R = 22536.46
VOL_RECORD value 15263 saved to /home/nagimov/soundcard.cfg
</code></pre><p>The measurement is done using the <a href=https://github.com/nagimov/sound-card-daq/blob/main/freq_sweep.py><code>freq_sweep.py</code> script</a>:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>matplotlib.pyplot</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>plt</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>

<span style=color:#60a0b0;font-style:italic># frequency sweep</span>
freq <span style=color:#666>=</span> np<span style=color:#666>.</span>geomspace(<span style=color:#40a070>3</span>, <span style=color:#40a070>20000</span>, num<span style=color:#666>=</span><span style=color:#40a070>200</span>)
<span style=color:#007020;font-weight:700>with</span> <span style=color:#007020>open</span>(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.csv&#39;</span>), <span style=color:#4070a0>&#39;w&#39;</span>) <span style=color:#007020;font-weight:700>as</span> csv:
    csv<span style=color:#666>.</span>write(<span style=color:#4070a0>&#39;freq, rms_L, rms_R</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
    <span style=color:#007020;font-weight:700>for</span> f <span style=color:#007020;font-weight:700>in</span> freq:
        w_L, w_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave(f))
        rms_L, rms_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>rms(w_L), sc<span style=color:#666>.</span>rms(w_R)
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;f = {f:.2f}, rms_L = {rms_L:.2f}, rms_R = {rms_R:.2f}&#39;</span>)
        csv<span style=color:#666>.</span>write(f<span style=color:#4070a0>&#39;{f:.2f}, {rms_L:.2f}, {rms_R:.2f}</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
sweep <span style=color:#666>=</span> np<span style=color:#666>.</span>genfromtxt(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.csv&#39;</span>), delimiter<span style=color:#666>=</span><span style=color:#4070a0>&#39;,&#39;</span>, names<span style=color:#666>=</span>True)
<span style=color:#60a0b0;font-style:italic># plot</span>
plt<span style=color:#666>.</span>figure(figsize<span style=color:#666>=</span>(<span style=color:#40a070>9</span>, <span style=color:#40a070>2</span>))
plt<span style=color:#666>.</span>plot(sweep[<span style=color:#4070a0>&#39;freq&#39;</span>], sweep[<span style=color:#4070a0>&#39;rms_L&#39;</span>], <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span><span style=color:#4070a0>&#39;L ch&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>plot(sweep[<span style=color:#4070a0>&#39;freq&#39;</span>], sweep[<span style=color:#4070a0>&#39;rms_R&#39;</span>], <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span><span style=color:#4070a0>&#39;R ch&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>tight_layout()
plt<span style=color:#666>.</span>legend(loc<span style=color:#666>=</span><span style=color:#4070a0>&#39;upper left&#39;</span>)
plt<span style=color:#666>.</span>xscale(<span style=color:#4070a0>&#39;log&#39;</span>)
plt<span style=color:#666>.</span>savefig(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.png&#39;</span>), dpi<span style=color:#666>=</span><span style=color:#40a070>100</span>)
</code></pre></div><p>The result of this measurement might look familiar &ndash; it is a typical frequency response curve of audio systems:</p><p><img src=/images/sound-card-daq/freq_sweep.png#center alt></p><p>In my case, the response curve is approximately flat in the interval from 30Hz to 17,000Hz. Note that this range is hardware-dependent: higher-end audio chips produce &ldquo;flatter&rdquo; response, while my 10-years old motherboard is far from the ideal &ldquo;20Hz to 20kHz&rdquo; range. This curve also defines a usable range for frequency response measurements &ndash; at frequencies below 30Hz or above 17,000Hz the sound card itself introduces measurement errors. This could be somewhat mitigated by introducing correction factors that account for sound card characteristics, but the benefits are not worth the additional steps in this case.</p><h4 id=capacitance-or-inductance-measurements>Capacitance or inductance measurements</h4><p>Now that the simple frequency response measurement is figured out, it could be extended to include the features required for capacitance or inductance measurements. Note that the example below uses a capacitive water level sensor with a fixed inductor, but the method can be adjusted for variable inductance sensors with fixed capacitors.</p><h4 id=circuit-design-1>Circuit design</h4><p>To read capacitance or inductance using frequency response curves, a measurement circuit must meet the following criteria:</p><ul><li>have an easily identifiable feature on its frequency characteristic</li><li>directly correlate this feature to the capacitance or inductance of its component</li><li>contain this feature within the usable frequency response range of the sound card</li></ul><p>The simplest circuit made of entirely resistors and capacitors that exhibits such behavior is a <a href=https://www.electronics-tutorials.ws/filter/filter_4.html>passive band-pass filter</a>:</p><p><img src=/images/sound-card-daq/CR-RC-band-pass-filter.png#center alt></p><p>When using identical resistors and capacitors on a low-pass and high-pass sides of the band-pass filter, the resulting frequency response peaks at its cut-off frequency:</p><pre><code>f = 1 / (2 * π * R * C)
</code></pre><p>However it has a disadvantage &ndash; in order for peak to be &ldquo;sharp&rdquo; and easily identifiable, capacitors in the circuit must be identical. This complicates measurement of capacitive sensors, i.e. two identical sensors measuring the same parameter must be used with this circuit.</p><p>At a cost of somewhat increased complexity due to an additional inductor, RLC circuits exhibit similar behavior and utilize only one capacitor. There are <a href=https://en.wikipedia.org/wiki/RLC_circuit>many topologies to choose from</a>. In this case, a series band-stop RLC filter is used:</p><p><img src=/images/sound-card-daq/RLC-band-stop-series.png#center alt></p><p>The response curve of this filter has a &ldquo;dip&rdquo; around its center frequency (see below). With a known inductance in the circuit, capacitance can be correlated to the frequency of the peak (and vice-versa for inductive measurements):</p><pre><code>f = 1 / (2 * π * sqrt(L * C))
</code></pre><p>Since the center frequency of RLC filters only depends on inductance and capacitance, knowledge of the reference gain is not required for frequency response measurements. This means that both audio channels can be used independently, allowing for simultaneous measurements of two capacitive or inductive sensors.</p><p>The inductor-capacitor combination must be chosen carefully to ensure that the center frequency of the band-stop filter can be accurately determined using the sound card. The usable frequency range of my sound card lies between 30Hz and 17,000Hz. In order to detect the peak on the frequency response characteristic, a few samples must be measured at frequencies below and above the peak. The corresponding center frequency of the band-stop filter should therefore be always higher than ~40Hz and lower than ~15,000Hz.</p><p>For capacitive measurements, constant inductances are used in the circuit. I salvaged my inductors from an old LED bulb, and they turned out to be 1.4mH and 3.3mH. Capacitance range that can be measured using 1.4mH inductor on my audio ADC is:</p><pre><code>C_min = 1 / (4 * π^2 * (15,000 Hz)^2 * 1.4e-3 H) = 80.414 nF
C_max = 1 / (4 * π^2 * (40 Hz)^2 * 1.4e-3 H) = 11308 uF
</code></pre><p>Range for 3.3mH inductor:</p><pre><code>C_min = 1 / (4 * π^2 * (15,000 Hz)^2 * 3.3e-3 H) = 34.115 nF
C_max = 1 / (4 * π^2 * (40 Hz)^2 * 3.3e-3 H) = 4797.4 uF
</code></pre><p>The capacitance of my DIY water level probe ranges from 0 to ~300nF. Since its lower bound is less than <code>C_min</code>, an additional capacitor must be added to offset the center frequency down to detectable ~15,000Hz and ensure that peaks on frequency characteristics are always detectable. Capacitors are selected by rounding up the values of <code>C_min</code>. In this case, a 100nF capacitor is added to a 1.4mH inductor and a 47nF capacitor is added to a 3.3 mH inductor. In this configuration, even the lowest capacitance of the sensor (i.e. at zero water level) produces frequency characteristics with a detectable peak:</p><pre><code>1 / (2 * π * sqrt(100e-9 F * 1.4e-3 H)) = 13451 Hz
1 / (2 * π * sqrt(47e-9 F * 3.3e-3 H)) = 12778 Hz
</code></pre><p>For inductive sensors, similar calculations can be used for capacitor selection.</p><p>Finite input impedance of audio ADCs (in the order of 10kΩ) eliminates the need for an additional resistor. Audio output is used to excite the circuit at various frequencies and the response is recorded at the input side. To simplify the math, capacitive sensors are connected in parallel with fixed capacitors, so the total capacitance of RLC filters is the sum of the two. For inductance measurements, sensors would be connected in series with fixed inductors, when required.</p><p><img src=/images/sound-card-daq/RLC-band-stop-series-audio.png#center alt></p><h4 id=hardware-setup-1>Hardware setup</h4><p>This simple stripboard allows quickly connecting the sensors and additional capacitors in parallel to the fixed capacitor via header pins and sockets:</p><p><img src=/images/sound-card-daq/capacitor-breakout-board.png#center alt></p><h4 id=software-setup-1>Software setup</h4><p>Center frequencies of RLC circuits on both channels are measured using <a href=https://github.com/nagimov/sound-card-daq/blob/main/freq_sweep_peak.py><code>freq_sweep_peak.py</code> script</a>:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>matplotlib.pyplot</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>plt</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>

peak, argpeak <span style=color:#666>=</span> np<span style=color:#666>.</span>min, np<span style=color:#666>.</span>argmin  <span style=color:#60a0b0;font-style:italic># replace with (np.max, np.argmax) for max values</span>

<span style=color:#60a0b0;font-style:italic># frequency sweep</span>
freq <span style=color:#666>=</span> np<span style=color:#666>.</span>geomspace(<span style=color:#40a070>30</span>, <span style=color:#40a070>17000</span>, num<span style=color:#666>=</span><span style=color:#40a070>100</span>)
<span style=color:#007020;font-weight:700>with</span> <span style=color:#007020>open</span>(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.csv&#39;</span>), <span style=color:#4070a0>&#39;w&#39;</span>) <span style=color:#007020;font-weight:700>as</span> csv:
    csv<span style=color:#666>.</span>write(<span style=color:#4070a0>&#39;freq, rms_L, rms_R</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
    <span style=color:#007020;font-weight:700>for</span> f <span style=color:#007020;font-weight:700>in</span> freq:
        w_L, w_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave(f))
        rms_L, rms_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>rms(w_L), sc<span style=color:#666>.</span>rms(w_R)
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;f = {f:.2f} Hz, rms_L = {rms_L:.2f}, rms_R = {rms_R:.2f}&#39;</span>)
        csv<span style=color:#666>.</span>write(f<span style=color:#4070a0>&#39;{f:.2f}, {rms_L:.2f}, {rms_R:.2f}</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#39;</span>)
sweep <span style=color:#666>=</span> np<span style=color:#666>.</span>genfromtxt(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.csv&#39;</span>), delimiter<span style=color:#666>=</span><span style=color:#4070a0>&#39;,&#39;</span>, names<span style=color:#666>=</span>True)
freq_L_peak, rms_L_peak <span style=color:#666>=</span> sweep[<span style=color:#4070a0>&#39;freq&#39;</span>][argpeak(sweep[<span style=color:#4070a0>&#39;rms_L&#39;</span>])], peak(sweep[<span style=color:#4070a0>&#39;rms_L&#39;</span>])
freq_R_peak, rms_R_peak <span style=color:#666>=</span> sweep[<span style=color:#4070a0>&#39;freq&#39;</span>][argpeak(sweep[<span style=color:#4070a0>&#39;rms_R&#39;</span>])], peak(sweep[<span style=color:#4070a0>&#39;rms_R&#39;</span>])
<span style=color:#60a0b0;font-style:italic># plot</span>
plt<span style=color:#666>.</span>figure(figsize<span style=color:#666>=</span>(<span style=color:#40a070>9</span>, <span style=color:#40a070>2</span>))
plt<span style=color:#666>.</span>plot(sweep[<span style=color:#4070a0>&#39;freq&#39;</span>], sweep[<span style=color:#4070a0>&#39;rms_L&#39;</span>], <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span>f<span style=color:#4070a0>&#39;L ch: peak @ {freq_L_peak:.2f} Hz&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>plot(sweep[<span style=color:#4070a0>&#39;freq&#39;</span>], sweep[<span style=color:#4070a0>&#39;rms_R&#39;</span>], <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span>f<span style=color:#4070a0>&#39;R ch: peak @ {freq_R_peak:.2f} Hz&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>plot([freq_L_peak, freq_R_peak], [rms_L_peak, rms_R_peak], <span style=color:#4070a0>&#39;+&#39;</span>, ms<span style=color:#666>=</span><span style=color:#40a070>7</span>)
plt<span style=color:#666>.</span>tight_layout()
plt<span style=color:#666>.</span>legend(loc<span style=color:#666>=</span><span style=color:#4070a0>&#39;lower left&#39;</span>)
plt<span style=color:#666>.</span>xscale(<span style=color:#4070a0>&#39;log&#39;</span>)
plt<span style=color:#666>.</span>savefig(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.png&#39;</span>), dpi<span style=color:#666>=</span><span style=color:#40a070>100</span>)
</code></pre></div><p>The center frequencies are detected at close to the expected values (<code>12778Hz</code> and <code>13451Hz</code>):</p><p><img src=/images/sound-card-daq/freq_sweep_peak.png#center alt></p><p>For the following plot, various capacitors are used to mock the sensor. Frequency response is measured for each capacitor on the left channel:</p><p><img src=/images/sound-card-daq/multiple_sweep_left.png#center alt></p><p>And on the right channel:</p><p><img src=/images/sound-card-daq/multiple_sweep_right.png#center alt></p><p>Note the differences between the channels:</p><ul><li>peaks are &ldquo;sharper&rdquo; and distributed further apart on the left channel, which improves the accuracy and resolution of detected peak frequencies</li><li>frequency range occupied by the peaks is narrower on the right channel, which increases the range of capacitances that could be measured with a given sound card</li></ul><p>This demonstrates that selection of inductors is a trade-off between measurement range and accuracy. The inductor affects both the absolute value of the center frequency (<code>f</code>) and the bandwidth of the filter (<code>Δf</code>):</p><pre><code>f = 1 / (2 * π * sqrt(L * C))
Δf = R / (2 * π * L)
</code></pre><p>Given a constant resistance <code>R</code> and capacitance <code>C</code>, higher inductance <code>L</code> will reduce the bandwidth of the filter (i.e. make the peaks &ldquo;sharper&rdquo;) at a cost of reduced sensitivity of the filter to changing capacitance <code>C</code>.</p><p>While reliably detecting the center frequency of the band-pass filter, the high-resolution frequency sweep requires a large number of measurements, and therefore takes a long time to complete. To reduce the measurement time, <a href=https://github.com/nagimov/sound-card-daq/blob/main/freq_iter_peak.py><code>freq_iter_peak.py</code> script</a> can be used. It employs a simple iterative optimization to find the peaks faster:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>matplotlib.pyplot</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>plt</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>

STEPS <span style=color:#666>=</span> <span style=color:#40a070>4</span>
ITERS <span style=color:#666>=</span> <span style=color:#40a070>4</span>

peak, argpeak <span style=color:#666>=</span> np<span style=color:#666>.</span>min, np<span style=color:#666>.</span>argmin  <span style=color:#60a0b0;font-style:italic># replace with (np.max, np.argmax) for max values</span>

<span style=color:#60a0b0;font-style:italic># optimization</span>
freq <span style=color:#666>=</span> {<span style=color:#4070a0>&#39;L&#39;</span>: np<span style=color:#666>.</span>geomspace(<span style=color:#40a070>30</span>, <span style=color:#40a070>17000</span>, num<span style=color:#666>=</span>STEPS)<span style=color:#666>.</span>tolist(), <span style=color:#4070a0>&#39;R&#39;</span>: np<span style=color:#666>.</span>geomspace(<span style=color:#40a070>30</span>, <span style=color:#40a070>17000</span>, num<span style=color:#666>=</span>STEPS)<span style=color:#666>.</span>tolist()}
rms <span style=color:#666>=</span> {<span style=color:#4070a0>&#39;L&#39;</span>: [], <span style=color:#4070a0>&#39;R&#39;</span>: []}
<span style=color:#007020;font-weight:700>for</span> n, ch <span style=color:#007020;font-weight:700>in</span> [(<span style=color:#40a070>0</span>, <span style=color:#4070a0>&#39;L&#39;</span>), (<span style=color:#40a070>1</span>, <span style=color:#4070a0>&#39;R&#39;</span>)]:
    <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;Optimizing channel {ch}&#39;</span>)
    <span style=color:#007020;font-weight:700>for</span> f <span style=color:#007020;font-weight:700>in</span> freq[ch]:
        w <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave(f))
        rms[ch]<span style=color:#666>.</span>append(sc<span style=color:#666>.</span>rms(w[n]))
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;f = {f:.2f} Hz, rms_{ch} = {rms[ch][-1]:.2f}&#39;</span>)
    <span style=color:#007020;font-weight:700>for</span> i <span style=color:#007020;font-weight:700>in</span> <span style=color:#007020>range</span>(ITERS):
        peak_indices <span style=color:#666>=</span> np<span style=color:#666>.</span>argwhere(rms[ch] <span style=color:#666>==</span> peak(rms[ch]))<span style=color:#666>.</span>flatten()
        peak_index_left, peak_index_right <span style=color:#666>=</span> <span style=color:#007020>max</span>(<span style=color:#40a070>0</span>, <span style=color:#007020>min</span>(peak_indices) <span style=color:#666>-</span> <span style=color:#40a070>1</span>), <span style=color:#007020>min</span>(<span style=color:#007020>max</span>(peak_indices) <span style=color:#666>+</span> <span style=color:#40a070>1</span>, <span style=color:#007020>len</span>(freq[ch]) <span style=color:#666>-</span> <span style=color:#40a070>1</span>)
        <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;{&#34; &#34;*4*i}refining peak: f_{ch} = {freq[ch][peak_indices[0]]:.2f} Hz, peak_{ch} = {peak(rms[ch]):.2f}&#39;</span>)
        freq_fine <span style=color:#666>=</span> np<span style=color:#666>.</span>geomspace(freq[ch][peak_index_left], freq[ch][peak_index_right], num<span style=color:#666>=</span>STEPS <span style=color:#666>+</span> <span style=color:#40a070>2</span>)
        freq_fine <span style=color:#666>=</span> [k <span style=color:#007020;font-weight:700>for</span> k <span style=color:#007020;font-weight:700>in</span> freq_fine[<span style=color:#40a070>1</span>:<span style=color:#666>-</span><span style=color:#40a070>1</span>] <span style=color:#007020;font-weight:700>if</span> k <span style=color:#007020;font-weight:700>not</span> <span style=color:#007020;font-weight:700>in</span> freq[ch]]  <span style=color:#60a0b0;font-style:italic># don&#39;t duplicate measurements</span>
        <span style=color:#007020;font-weight:700>for</span> f <span style=color:#007020;font-weight:700>in</span> freq_fine:
            freq_pos <span style=color:#666>=</span> np<span style=color:#666>.</span>argwhere(f <span style=color:#666>&lt;</span> np<span style=color:#666>.</span>array(freq[ch]))<span style=color:#666>.</span>flatten()[<span style=color:#40a070>0</span>]
            w <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>sine_wave(f))
            rms[ch]<span style=color:#666>.</span>insert(freq_pos, sc<span style=color:#666>.</span>rms(w[n]))
            freq[ch]<span style=color:#666>.</span>insert(freq_pos, f)
            <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;{&#34; &#34;*4*(i+1)}f = {f:.2f} Hz, rms_{ch} = {rms[ch][freq_pos]:.2f}&#39;</span>)
    peak_indices <span style=color:#666>=</span> np<span style=color:#666>.</span>argwhere(rms[ch] <span style=color:#666>==</span> peak(rms[ch]))<span style=color:#666>.</span>flatten()
    peak_freq <span style=color:#666>=</span> freq[ch][peak_indices[<span style=color:#007020>len</span>(peak_indices) <span style=color:#666>//</span> <span style=color:#40a070>2</span>]]
    <span style=color:#007020;font-weight:700>print</span>(f<span style=color:#4070a0>&#39;{&#34;    &#34;*ITERS}final peak: f_{ch} = {peak_freq:.2f} Hz, rms_{ch} = {peak(rms[ch]):.2f}&#39;</span>)
    freq[f<span style=color:#4070a0>&#39;{ch}_peak&#39;</span>], rms[f<span style=color:#4070a0>&#39;{ch}_peak&#39;</span>] <span style=color:#666>=</span> freq[ch][argpeak(rms[ch])], peak(rms[ch])
<span style=color:#60a0b0;font-style:italic># plot</span>
plt<span style=color:#666>.</span>figure(figsize<span style=color:#666>=</span>(<span style=color:#40a070>9</span>, <span style=color:#40a070>2</span>))
<span style=color:#007020;font-weight:700>for</span> ch <span style=color:#007020;font-weight:700>in</span> [<span style=color:#4070a0>&#39;L&#39;</span>, <span style=color:#4070a0>&#39;R&#39;</span>]:
    plt<span style=color:#666>.</span>plot(freq[ch], rms[ch], <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span>f<span style=color:#4070a0>&#39;{ch} ch: peak @ {freq[f&#34;{ch}_peak&#34;]:.2f} Hz&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>3</span>)
    plt<span style=color:#666>.</span>plot(freq[f<span style=color:#4070a0>&#39;{ch}_peak&#39;</span>], rms[f<span style=color:#4070a0>&#39;{ch}_peak&#39;</span>], <span style=color:#4070a0>&#39;+&#39;</span>, ms<span style=color:#666>=</span><span style=color:#40a070>7</span>)
plt<span style=color:#666>.</span>tight_layout()
plt<span style=color:#666>.</span>legend(loc<span style=color:#666>=</span><span style=color:#4070a0>&#39;lower left&#39;</span>)
plt<span style=color:#666>.</span>xscale(<span style=color:#4070a0>&#39;log&#39;</span>)
plt<span style=color:#666>.</span>savefig(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.png&#39;</span>), dpi<span style=color:#666>=</span><span style=color:#40a070>100</span>)
</code></pre></div><p><em>Off-topic note: reducing the number of measurements required to find the center frequencies of RLC-circuits is a typical example of mathematical optimization. The iterative approach described above utilizes the simplest <a href=https://en.wikipedia.org/wiki/Greedy_algorithm>Greedy algorithm</a> to find the local minimum of the frequency characteristic. More complicated optimization algorithms (e.g. <a href=https://en.wikipedia.org/wiki/Gradient_descent>Gradient descent</a>) can be employed to reduce the measurement time even further.</em></p><p>This graph demonstrates why it is both faster and more accurate. Since measurements are only taken around &ldquo;important&rdquo; regions of interest, every consecutive measurement further improves the accuracy:</p><p><img src=/images/sound-card-daq/freq_iter_peak.png#center alt></p><p>Can we do any faster? Yes! The <a href=https://github.com/nagimov/sound-card-daq/blob/main/freq_fft_peak.py><code>freq_fft_peak.py</code> script</a> can be used to excite the circuit with <a href=https://en.wikipedia.org/wiki/White_noise>white noise</a> and measure the frequency response at the output in a single measurement using a <a href=https://en.wikipedia.org/wiki/Fast_Fourier_transform>Fast Fourier Transform</a>. While the theory behind this method is heavy on math, the implementation is very simple thanks to the python libraries:</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>matplotlib.pyplot</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>plt</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>numpy</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>np</span>
<span style=color:#007020;font-weight:700>import</span> <span style=color:#0e84b5;font-weight:700>soundcard</span> <span style=color:#007020;font-weight:700>as</span> <span style=color:#0e84b5;font-weight:700>sc</span>

peak, argpeak <span style=color:#666>=</span> np<span style=color:#666>.</span>min, np<span style=color:#666>.</span>argmin  <span style=color:#60a0b0;font-style:italic># replace with (np.max, np.argmax) for max values</span>

<span style=color:#60a0b0;font-style:italic># fft peak</span>
freq_bins <span style=color:#666>=</span> np<span style=color:#666>.</span>geomspace(<span style=color:#40a070>30</span>, <span style=color:#40a070>17000</span>, <span style=color:#40a070>300</span>)
freq_bins_cent <span style=color:#666>=</span> [np<span style=color:#666>.</span>mean([lo, hi]) <span style=color:#007020;font-weight:700>for</span> lo, hi <span style=color:#007020;font-weight:700>in</span> <span style=color:#007020>zip</span>(freq_bins[:<span style=color:#666>-</span><span style=color:#40a070>1</span>], freq_bins[<span style=color:#40a070>1</span>:])]
w_L, w_R <span style=color:#666>=</span> sc<span style=color:#666>.</span>play_and_record(sc<span style=color:#666>.</span>white_noise())
freq <span style=color:#666>=</span> np<span style=color:#666>.</span>fft<span style=color:#666>.</span>rfftfreq(<span style=color:#007020>len</span>(w_L), <span style=color:#40a070>1</span> <span style=color:#666>/</span> sc<span style=color:#666>.</span>SAMPLE_RATE)
fft_L, fft_R <span style=color:#666>=</span> np<span style=color:#666>.</span>abs(np<span style=color:#666>.</span>fft<span style=color:#666>.</span>rfft(w_L)), np<span style=color:#666>.</span>abs(np<span style=color:#666>.</span>fft<span style=color:#666>.</span>rfft(w_R))
fft_L_bins <span style=color:#666>=</span> [np<span style=color:#666>.</span>mean(fft_L[np<span style=color:#666>.</span>where((freq <span style=color:#666>&gt;</span> lo) <span style=color:#666>&amp;</span> (freq <span style=color:#666>&lt;=</span> hi))]) <span style=color:#007020;font-weight:700>for</span> lo, hi <span style=color:#007020;font-weight:700>in</span> <span style=color:#007020>zip</span>(freq_bins[:<span style=color:#666>-</span><span style=color:#40a070>1</span>], freq_bins[<span style=color:#40a070>1</span>:])]
fft_R_bins <span style=color:#666>=</span> [np<span style=color:#666>.</span>mean(fft_R[np<span style=color:#666>.</span>where((freq <span style=color:#666>&gt;</span> lo) <span style=color:#666>&amp;</span> (freq <span style=color:#666>&lt;=</span> hi))]) <span style=color:#007020;font-weight:700>for</span> lo, hi <span style=color:#007020;font-weight:700>in</span> <span style=color:#007020>zip</span>(freq_bins[:<span style=color:#666>-</span><span style=color:#40a070>1</span>], freq_bins[<span style=color:#40a070>1</span>:])]
freq_L_peak, fft_L_peak <span style=color:#666>=</span> freq_bins_cent[argpeak(fft_L_bins)], peak(fft_L_bins)
freq_R_peak, fft_R_peak <span style=color:#666>=</span> freq_bins_cent[argpeak(fft_R_bins)], peak(fft_R_bins)
<span style=color:#60a0b0;font-style:italic># plot</span>
scale <span style=color:#666>=</span> <span style=color:#40a070>0.01</span>
plt<span style=color:#666>.</span>figure(figsize<span style=color:#666>=</span>(<span style=color:#40a070>9</span>, <span style=color:#40a070>2</span>))
plt<span style=color:#666>.</span>plot(freq_bins_cent, np<span style=color:#666>.</span>array(fft_L_bins)<span style=color:#666>*</span>scale, <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span>f<span style=color:#4070a0>&#39;L ch: peak @ {freq_L_peak:.2f} Hz&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>plot(freq_bins_cent, np<span style=color:#666>.</span>array(fft_R_bins)<span style=color:#666>*</span>scale, <span style=color:#4070a0>&#39;.-&#39;</span>, label<span style=color:#666>=</span>f<span style=color:#4070a0>&#39;R ch: peak @ {freq_R_peak:.2f} Hz&#39;</span>, lw<span style=color:#666>=</span><span style=color:#40a070>0.5</span>, ms<span style=color:#666>=</span><span style=color:#40a070>1</span>)
plt<span style=color:#666>.</span>plot([freq_L_peak, freq_R_peak], [fft_L_peak<span style=color:#666>*</span>scale, fft_R_peak<span style=color:#666>*</span>scale], <span style=color:#4070a0>&#39;+&#39;</span>, ms<span style=color:#666>=</span><span style=color:#40a070>7</span>)
plt<span style=color:#666>.</span>tight_layout()
plt<span style=color:#666>.</span>legend(loc<span style=color:#666>=</span><span style=color:#4070a0>&#39;lower left&#39;</span>)
plt<span style=color:#666>.</span>xscale(<span style=color:#4070a0>&#39;log&#39;</span>)
plt<span style=color:#666>.</span>savefig(__file__<span style=color:#666>.</span>replace(<span style=color:#4070a0>&#39;.py&#39;</span>, <span style=color:#4070a0>&#39;.png&#39;</span>), dpi<span style=color:#666>=</span><span style=color:#40a070>100</span>)
</code></pre></div><p>As a result, the entire frequency range is analyzed in a single measurement. Note that the peaks are consistent with values from the iterative optimization plot:</p><p><img src=/images/sound-card-daq/freq_fft_peak.png#center alt></p><p>The last step is to back-calculate the capacitance from the frequency response. The above two charts are taken using a 470nF capacitor on the left channel and a 47nF capacitor on the right channel. Measurements are within ±10% of expected values:</p><pre><code>C_L = 1 / (4 * π^2 * (3,800 Hz)^2 * 3.3e-3 H) - 47e-9 F = 484 nF
C_R = 1 / (4 * π^2 * (11,200 Hz)^2 * 1.4e-3 H) - 100e-9 F = 44.2 nF
</code></pre><h4 id=water-level-measurement>Water level measurement</h4><p>A useful example of a capacitive sensor is a liquid level probe. The sensor can be easily made from two pieces of aluminum foil, affixed close to each other without touching anywhere. I used two 3d-printed plastic frames to hold two strips of foil using super-glue, and attached a piece of jumper wire onto each strip:</p><p><center><img src=/images/sound-card-daq/frames.jpg> <img src=/images/sound-card-daq/level_probe.jpg></center></p><p>When the water level goes up it fills a portion of the gap between the wires. Since the relative permittivity of water is ~80 times higher than that of air, the total capacitance of the sensor increases. This change in capacitance can be detected and translated to a liquid level:</p><p><img src=/images/sound-card-daq/liquid_level.gif#center alt></p><h3 id=troubleshooting>Troubleshooting</h3><ul><li>Depending on the setup (PC configuration, current CPU load, etc.), OS &ldquo;reaction time&rdquo; can vary. Sometimes it takes a second or two for PulseAudio to play the wave file, there is another delay for the recording process to &ldquo;catch up&rdquo;, etc. To achieve consistent measurements, delays are introduced into the playing and recording sequence. If used on an outdated hardware, timing variables (<code>DURATION_RECORD</code>, <code>PAUSE_PRE_PLAY</code>, <code>PAUSE_PRE_RECORD</code>, <code>PAUSE_POST_RECORD</code>, and <code>DURATION_PLAY</code>) might need to be increased in the <code>soundcard.py</code> module. Alternatively, when used on a fast modern PC, these variables can be decreased to speed up the measurements.</li><li>Whenever PulseAudio errors are displayed (e.g. <code>Stream error: No such entity</code> or <code>No sink/source found by this name or index</code>), make sure that correct PulseAudio source and sink are specified in the <code>soundcard.cfg</code> file.</li></ul><hr></div></div><div class=row><div class=col-md-12 style=display:flex;justify-content:space-between><div>Tagged
#<a href=/tags/themistor>themistor</a>
,
#<a href=/tags/temperature>temperature</a>
,
#<a href=/tags/level-probe>level probe</a>
,
#<a href=/tags/liquid-level>liquid level</a>
,
#<a href=/tags/resistive-sensor>resistive sensor</a>
,
#<a href=/tags/capacitive-sensor>capacitive sensor</a>
,
#<a href=/tags/sound-card>sound card</a>
,
#<a href=/tags/monitoring>monitoring</a>
,
#<a href=/tags/voltage-divider>voltage divider</a>
,
#<a href=/tags/pass-band-filter>pass band filter</a></div><div><span class="label label-primary">2021-06-23</span></div></div></div><div class=row><div class=col-md-12><hr></div></div><div class=row><div class=col-md-12><div id=remark42></div></div></div></div><div class=container><div class="row col-md-12"><footer><div class=pull-left><p>&copy; 2021 Ruslan Nagimov ~ Powered By <a href=https://gohugo.io>Hugo</a> ~ <a href=https://creativecommons.org/licenses/by/4.0/>License: CC BY 4.0</a></p></div><div class=pull-right><a href=https://github.com/nagimov target=_blank><i class="fa fa-github-square fa-2x"></i></a></div></footer></div></div></body></html>